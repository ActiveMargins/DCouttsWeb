---
title: 'Exploring the inner-workings and decisions behind stRat stat'
author: Danny
date: '2021-01-21'
slug: []
categories:
  - Blog
tags:
  - Geology
  - RShiny
subtitle: 'Diving into a complex RShiny app'
description: 'The hurdles and solutions behind creating an app that allows geologist to turn graphic logs/core logs into a tabulated rich data format'
image: ''
---

Designing a piece of software is challenging - defining bottomline requirements, user desires, platform limits, is very tricky. stRat stat was my first attempt at creating a cohesive application. This post focuses more on the main programming hurdles and solutions involved in implementation. If you want to know more about the features and uses, check out [GitHub repo](https://github.com/ActiveMargins/stRatstat) or my [2020 CSPG talk on stRat stat](https://www.youtube.com/watch?v=4cbkrBNZ2o4&ab_channel=CptCatastrophe).

## Graphic logs - the problem

Graphic logs (i.e., drawn core logs or measured sections) are one of the most commonly used tools to illustrate geologic heterogeneity of sedimentary deposits. These data types are entirely graphical, often drawn by hand in the field and then digitized in a drafting software (e.g., Adobe Illustrator, Corel Draw). Although they are very common, they are rarely leveraged for more than visual analysis and description.

A distinct problem with the implementation of these data into a digital framework is the richness (amount of data) and diversity of data. In regards to the creation of graphic logs, geologists follow few data schemes beyond names of sedimentary structures and lithologies. Some geologists use generic symbols to represent sedimentary structures and rock types, others draw what they see. Additionally the image can be flipped (coarsening to the right, or coarsening to the left). In regards to what appears in a graphic log the program needed to be able to include any of hundreds of sedimentary structures, and infinite names for different rocks. Lastly, geologist like to visualize data (often without the use of a programming language) and correlate what they see in the rocks to other measurements they've made. 

## stRat stat design challenges

A long time ago I saw a MatLab application created by Zane Jobe (Colorado School of Mines), Nick Howes (Mathworks), and John Martin (Shell) when they were all working at Shell that was used to digitize graphic logs. I was looking for a project to learn R and decided I would create an RShiny application that operated along similar lines - I decided to solve the same problem.

Working off the same idea as the Shell team (point-and-click digitization) I took a while to outline my own workflow, processes, and exports, to solve the same problem. I designed stRat stat to have few coded inputs and rely mainly on user-generated fields. This way users could apply this software to any graphic log of a clastic deposit. Some early decisions and hurdles are highlighted below.

**1) RShiny GUI:** Using RShiny as the foundation of the app provided an incredible GUI experience and be web-ready by default. Digitization is completed by clicking and brushing on rendered ggplots while stRat stat collects the location of those interactions. Leveraging this package provided some limitations but allowed me to be working working on UI/UX integration from my first day working on the project. 

**2) User-generated rock classifications:** Geologist have different naming conventions for groups of rocks. User-generated categories were implemented so that users can apply their naming conventions to graphic logs. This there is not a list of rock types or features where only 1% is applicable to the project at hand. This UI has two steps. First, a text input takes the input name (e.g., thick-bedded sandstone) to an array that contains all the names that have been generated by that user. Secondly, a set of radio-buttons is rendered that includes all the names in the first array. Users interact with these radio buttons to select which type of rock or rock feature they want logged in the interval they selected. Because geologists have specific names and requirements, this process is almost expected by the user, however by implementing this user interface in multiple places (sedimentary structures, facies, elements, element-sets) this workflow becomes very familiar to the user. Lastly, the information created by the user can be easily stored save file (when work is saved for later) so that these options are loaded back in.

**3) Tidy data framework for export .csv:** A large goal of this project was to provide geologists the data that allow them to better understand the variability that they capture in their graphic logs. This may be comparing the difference between two different categories of rocks (mudstones vs. sandstones) or analyzing intra-category variability. To streamline this, a native [Tidy Format](https://vita.had.co.nz/papers/tidy-data.pdf) was implemented where each instances of a categories (bed, facies, element, ...) are given a unique ID. This allows for data to be summarized (group_by() %>% summarize()) based on these unique ID.

**4) Joining discrete and continuous data:** Geologist love sampling rocks and testing them in innumerable ways (isotopes, organics, mineralogy, density, etc.). This is how geologist make inferences about how the Earth has changed over time. These samples need to be related to the rock interval that they come from and are either discrete measurements (a rock sample taken for isotope measurement) or can be rather continuous (well logs collected along a borehole). The goal of this feature was to allow users to join measurements to a already digitized section and summarize them based on the scheme they've outlined. Discrete measurements can be joined to the section at the relevant depth or thickness. Continuous measurements can be collected at various sampling rates (mm between measurements or cm between measurements) and need to match the the scale of the graphic log. This was achieved through interpolation or calculating a rolling mean (depending on the scale), then joining the data to the input log.    


## Main learnings (0 to 60 in software design and R)

This project is how I started learning R. It might have been a bit ambitious, but worked out in the end.

**1) Work within your domain knowledge:** Because this my first large project I found that working within my domain knowledge (sedimentary geology) allowed me to better understand the needs and requirements of the tool and users.

**2) Learning RShiny:** RShiny has a lot of interesting syntax in the form of reactive variables and elements. This was very hard for me to figure out in the beginning but documentation and online examples are very excellent! If you're interested in this kind of tool but work in a different language, there are similar packages/libraries in Python (e.g., Streamlit)


## What's happening with stRat stat in 2021

Zane and the original tool authors at Shell, along with Zane's group at CSM, have been very welcoming to my implementation of the tool in R. Zane has been spearheading a project that takes the export .csv from stRat stat or the Matlab Digitizer produce visualizations that aid in understanding the heterogeneity at a bed or facies level.